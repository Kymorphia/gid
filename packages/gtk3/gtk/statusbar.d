module gtk.statusbar;

import atk.implementor_iface;
import atk.implementor_iface_mixin;
import gid.gid;
import gobject.dclosure;
import gobject.object;
import gtk.box;
import gtk.buildable;
import gtk.buildable_mixin;
import gtk.c.functions;
import gtk.c.types;
import gtk.container;
import gtk.orientable;
import gtk.orientable_mixin;
import gtk.types;

/**
    A #GtkStatusbar is usually placed along the bottom of an application's
  main #GtkWindow. It may provide a regular commentary of the application's
  status (as is usually the case in a web browser, for example), or may be
  used to simply output a message when the status changes, (when an upload
  is complete in an FTP client, for example).
  
  Status bars in GTK+ maintain a stack of messages. The message at
  the top of the each bar’s stack is the one that will currently be displayed.
  
  Any messages added to a statusbar’s stack must specify a
  context id that is used to uniquely identify
  the source of a message. This context id can be generated by
  [gtk.statusbar.Statusbar.getContextId], given a message and the statusbar that
  it will be added to. Note that messages are stored in a stack, and when
  choosing which message to display, the stack structure is adhered to,
  regardless of the context identifier of a message.
  
  One could say that a statusbar maintains one stack of messages for
  display purposes, but allows multiple message producers to maintain
  sub-stacks of the messages they produced (via context ids).
  
  Status bars are created using [gtk.statusbar.Statusbar.new_].
  
  Messages are added to the bar’s stack with [gtk.statusbar.Statusbar.push].
  
  The message at the top of the stack can be removed using
  [gtk.statusbar.Statusbar.pop]. A message can be removed from anywhere in the
  stack if its message id was recorded at the time it was added. This
  is done using [gtk.statusbar.Statusbar.remove].
  
  # CSS node
  
  GtkStatusbar has a single CSS node with name statusbar.
*/
class Statusbar : gtk.box.Box
{

  this(void* ptr, Flag!"Take" take = No.Take)
  {
    super(cast(void*)ptr, take);
  }

  static GType getType()
  {
    import gid.loader : gidSymbolNotFound;
    return cast(void function())gtk_statusbar_get_type != &gidSymbolNotFound ? gtk_statusbar_get_type() : cast(GType)0;
  }

  override @property GType gType()
  {
    return getType();
  }

  /**
      Creates a new #GtkStatusbar ready for messages.
    Returns:     the new #GtkStatusbar
  */
  this()
  {
    GtkWidget* _cretval;
    _cretval = gtk_statusbar_new();
    this(_cretval, No.Take);
  }

  /**
      Returns a new context identifier, given a description
    of the actual context. Note that the description is
    not shown in the UI.
    Params:
      contextDescription =       textual description of what context
                              the new message is being used in
    Returns:     an integer id
  */
  uint getContextId(string contextDescription)
  {
    uint _retval;
    const(char)* _contextDescription = contextDescription.toCString(No.Alloc);
    _retval = gtk_statusbar_get_context_id(cast(GtkStatusbar*)cPtr, _contextDescription);
    return _retval;
  }

  /**
      Retrieves the box containing the label widget.
    Returns:     a #GtkBox
  */
  gtk.box.Box getMessageArea()
  {
    GtkWidget* _cretval;
    _cretval = gtk_statusbar_get_message_area(cast(GtkStatusbar*)cPtr);
    auto _retval = ObjectG.getDObject!(gtk.box.Box)(cast(GtkWidget*)_cretval, No.Take);
    return _retval;
  }

  /**
      Removes the first message in the #GtkStatusbar’s stack
    with the given context id.
    
    Note that this may not change the displayed message, if
    the message at the top of the stack has a different
    context id.
    Params:
      contextId =       a context identifier
  */
  void pop(uint contextId)
  {
    gtk_statusbar_pop(cast(GtkStatusbar*)cPtr, contextId);
  }

  /**
      Pushes a new message onto a statusbar’s stack.
    Params:
      contextId =       the message’s context id, as returned by
                     [gtk.statusbar.Statusbar.getContextId]
      text =       the message to add to the statusbar
    Returns:     a message id that can be used with
               [gtk.statusbar.Statusbar.remove].
  */
  uint push(uint contextId, string text)
  {
    uint _retval;
    const(char)* _text = text.toCString(No.Alloc);
    _retval = gtk_statusbar_push(cast(GtkStatusbar*)cPtr, contextId, _text);
    return _retval;
  }

  alias remove = gtk.container.Container.remove;

  /**
      Forces the removal of a message from a statusbar’s stack.
    The exact context_id and message_id must be specified.
    Params:
      contextId =       a context identifier
      messageId =       a message identifier, as returned by [gtk.statusbar.Statusbar.push]
  */
  void remove(uint contextId, uint messageId)
  {
    gtk_statusbar_remove(cast(GtkStatusbar*)cPtr, contextId, messageId);
  }

  /**
      Forces the removal of all messages from a statusbar's
    stack with the exact context_id.
    Params:
      contextId =       a context identifier
  */
  void removeAll(uint contextId)
  {
    gtk_statusbar_remove_all(cast(GtkStatusbar*)cPtr, contextId);
  }

  /**
      Is emitted whenever a new message is popped off a statusbar's stack.
  
    ## Parameters
    $(LIST
      * $(B contextId)       the context id of the relevant message/statusbar
      * $(B text)       the message that was just popped
      * $(B statusbar) the instance the signal is connected to
    )
  */
  alias TextPoppedCallbackDlg = void delegate(uint contextId, string text, gtk.statusbar.Statusbar statusbar);

  /** ditto */
  alias TextPoppedCallbackFunc = void function(uint contextId, string text, gtk.statusbar.Statusbar statusbar);

  /**
    Connect to TextPopped signal.
    Params:
      callback = signal callback delegate or function to connect
      after = Yes.After to execute callback after default handler, No.After to execute before (default)
    Returns: Signal ID
  */
  ulong connectTextPopped(T)(T callback, Flag!"After" after = No.After)
  if (is(T : TextPoppedCallbackDlg) || is(T : TextPoppedCallbackFunc))
  {
    extern(C) void _cmarshal(GClosure* _closure, GValue* _returnValue, uint _nParams, const(GValue)* _paramVals, void* _invocHint, void* _marshalData)
    {
      assert(_nParams == 3, "Unexpected number of signal parameters");
      auto _dClosure = cast(DGClosure!T*)_closure;
      auto statusbar = getVal!(gtk.statusbar.Statusbar)(_paramVals);
      auto contextId = getVal!(uint)(&_paramVals[1]);
      auto text = getVal!(string)(&_paramVals[2]);
      _dClosure.dlg(contextId, text, statusbar);
    }

    auto closure = new DClosure(callback, &_cmarshal);
    return connectSignalClosure("text-popped", closure, after);
  }

  /**
      Is emitted whenever a new message gets pushed onto a statusbar's stack.
  
    ## Parameters
    $(LIST
      * $(B contextId)       the context id of the relevant message/statusbar
      * $(B text)       the message that was pushed
      * $(B statusbar) the instance the signal is connected to
    )
  */
  alias TextPushedCallbackDlg = void delegate(uint contextId, string text, gtk.statusbar.Statusbar statusbar);

  /** ditto */
  alias TextPushedCallbackFunc = void function(uint contextId, string text, gtk.statusbar.Statusbar statusbar);

  /**
    Connect to TextPushed signal.
    Params:
      callback = signal callback delegate or function to connect
      after = Yes.After to execute callback after default handler, No.After to execute before (default)
    Returns: Signal ID
  */
  ulong connectTextPushed(T)(T callback, Flag!"After" after = No.After)
  if (is(T : TextPushedCallbackDlg) || is(T : TextPushedCallbackFunc))
  {
    extern(C) void _cmarshal(GClosure* _closure, GValue* _returnValue, uint _nParams, const(GValue)* _paramVals, void* _invocHint, void* _marshalData)
    {
      assert(_nParams == 3, "Unexpected number of signal parameters");
      auto _dClosure = cast(DGClosure!T*)_closure;
      auto statusbar = getVal!(gtk.statusbar.Statusbar)(_paramVals);
      auto contextId = getVal!(uint)(&_paramVals[1]);
      auto text = getVal!(string)(&_paramVals[2]);
      _dClosure.dlg(contextId, text, statusbar);
    }

    auto closure = new DClosure(callback, &_cmarshal);
    return connectSignalClosure("text-pushed", closure, after);
  }
}
