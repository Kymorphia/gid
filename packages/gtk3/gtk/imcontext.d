/// Module for [IMContext] class
module gtk.imcontext;

import gdk.event_key;
import gdk.rectangle;
import gdk.window;
import gid.gid;
import gobject.dclosure;
import gobject.object;
import gtk.c.functions;
import gtk.c.types;
import gtk.types;
import pango.attr_list;

/**
    #GtkIMContext defines the interface for GTK+ input methods. An input method
    is used by GTK+ text input widgets like #GtkEntry to map from key events to
    Unicode character strings.
    
    The default input method can be set programmatically via the
    #GtkSettings:gtk-im-module GtkSettings property. Alternatively, you may set
    the GTK_IM_MODULE environment variable as documented in
    [Running GTK+ Applications][gtk-running].
    
    The #GtkEntry #GtkEntry:im-module and #GtkTextView #GtkTextView:im-module
    properties may also be used to set input methods for specific widget
    instances. For instance, a certain entry widget might be expected to contain
    certain characters which would be easier to input with a certain input
    method.
    
    An input method may consume multiple key events in sequence and finally
    output the composed result. This is called preediting, and an input method
    may provide feedback about this process by displaying the intermediate
    composition states as preedit text. For instance, the default GTK+ input
    method implements the input of arbitrary Unicode code points by holding down
    the Control and Shift keys and then typing “U” followed by the hexadecimal
    digits of the code point.  When releasing the Control and Shift keys,
    preediting ends and the character is inserted as text. Ctrl+Shift+u20AC for
    example results in the € sign.
    
    Additional input methods can be made available for use by GTK+ widgets as
    loadable modules. An input method module is a small shared library which
    implements a subclass of #GtkIMContext or #GtkIMContextSimple and exports
    these four functions:
    
    ```c
    void im_module_init(GTypeModule *module);
    ```
    This function should register the #GType of the #GtkIMContext subclass which
    implements the input method by means of [gobject.type_module.TypeModule.registerType]. Note
    that [gobject.global.typeRegisterStatic] cannot be used as the type needs to be
    registered dynamically.
    
    ```c
    void im_module_exit(void);
    ```
    Here goes any cleanup code your input method might require on module unload.
    
    ```c
    void im_module_list(const GtkIMContextInfo ***contexts, int *n_contexts)
    {
      *contexts = info_list;
      *n_contexts = G_N_ELEMENTS (info_list);
    }
    ```
    This function returns the list of input methods provided by the module. The
    example implementation above shows a common solution and simply returns a
    pointer to statically defined array of #GtkIMContextInfo items for each
    provided input method.
    
    ```c
    GtkIMContext * im_module_create(const gchar *context_id);
    ```
    This function should return a pointer to a newly created instance of the
    #GtkIMContext subclass identified by @context_id. The context ID is the same
    as specified in the #GtkIMContextInfo array returned by im_module_list().
    
    After a new loadable input method module has been installed on the system,
    the configuration file `gtk.immodules` needs to be
    regenerated by [gtk-query-immodules-3.0][gtk-query-immodules-3.0],
    in order for the new input method to become available to GTK+ applications.
*/
class IMContext : gobject.object.ObjectWrap
{

  /** */
  this(void* ptr, Flag!"Take" take = No.Take)
  {
    super(cast(void*)ptr, take);
  }

  /** */
  static GType getGType()
  {
    import gid.loader : gidSymbolNotFound;
    return cast(void function())gtk_im_context_get_type != &gidSymbolNotFound ? gtk_im_context_get_type() : cast(GType)0;
  }

  /** */
  override @property GType gType()
  {
    return getGType();
  }

  /** Returns `this`, for use in `with` statements. */
  override IMContext self()
  {
    return this;
  }

  /** */
  @property gtk.types.InputHints inputHints()
  {
    return gobject.object.ObjectWrap.getProperty!(gtk.types.InputHints)("input-hints");
  }

  /** */
  @property void inputHints(gtk.types.InputHints propval)
  {
    gobject.object.ObjectWrap.setProperty!(gtk.types.InputHints)("input-hints", propval);
  }

  /** */
  @property gtk.types.InputPurpose inputPurpose()
  {
    return gobject.object.ObjectWrap.getProperty!(gtk.types.InputPurpose)("input-purpose");
  }

  /** */
  @property void inputPurpose(gtk.types.InputPurpose propval)
  {
    gobject.object.ObjectWrap.setProperty!(gtk.types.InputPurpose)("input-purpose", propval);
  }

  /**
      Asks the widget that the input context is attached to to delete
      characters around the cursor position by emitting the
      GtkIMContext::delete_surrounding signal. Note that offset and n_chars
      are in characters not in bytes which differs from the usage other
      places in #GtkIMContext.
      
      In order to use this function, you should first call
      [gtk.imcontext.IMContext.getSurrounding] to get the current context, and
      call this function immediately afterwards to make sure that you
      know what you are deleting. You should also account for the fact
      that even if the signal was handled, the input context might not
      have deleted all the characters that were requested to be deleted.
      
      This function is used by an input method that wants to make
      subsitutions in the existing text in response to new input. It is
      not useful for applications.
  
      Params:
        offset = offset from cursor position in chars;
             a negative value means start before the cursor.
        nChars = number of characters to delete.
      Returns: true if the signal was handled.
  */
  bool deleteSurrounding(int offset, int nChars)
  {
    bool _retval;
    _retval = gtk_im_context_delete_surrounding(cast(GtkIMContext*)cPtr, offset, nChars);
    return _retval;
  }

  /**
      Allow an input method to internally handle key press and release
      events. If this function returns true, then no further processing
      should be done for this key event.
  
      Params:
        event = the key event
      Returns: true if the input method handled the key event.
  */
  bool filterKeypress(gdk.event_key.EventKey event)
  {
    bool _retval;
    _retval = gtk_im_context_filter_keypress(cast(GtkIMContext*)cPtr, event ? cast(GdkEventKey*)event.cPtr : null);
    return _retval;
  }

  /**
      Notify the input method that the widget to which this
      input context corresponds has gained focus. The input method
      may, for example, change the displayed feedback to reflect
      this change.
  */
  void focusIn()
  {
    gtk_im_context_focus_in(cast(GtkIMContext*)cPtr);
  }

  /**
      Notify the input method that the widget to which this
      input context corresponds has lost focus. The input method
      may, for example, change the displayed feedback or reset the contexts
      state to reflect this change.
  */
  void focusOut()
  {
    gtk_im_context_focus_out(cast(GtkIMContext*)cPtr);
  }

  /**
      Retrieve the current preedit string for the input context,
      and a list of attributes to apply to the string.
      This string should be displayed inserted at the insertion
      point.
  
      Params:
        str = location to store the retrieved
                       string. The string retrieved must be freed with [glib.global.gfree].
        attrs = location to store the retrieved
                       attribute list.  When you are done with this list, you
                       must unreference it with [pango.attr_list.AttrList.unref].
        cursorPos = location to store position of cursor (in characters)
                       within the preedit string.
  */
  void getPreeditString(out string str, out pango.attr_list.AttrList attrs, out int cursorPos)
  {
    char* _str;
    PangoAttrList* _attrs;
    gtk_im_context_get_preedit_string(cast(GtkIMContext*)cPtr, &_str, &_attrs, cast(int*)&cursorPos);
    str = _str.fromCString(Yes.Free);
    attrs = new pango.attr_list.AttrList(cast(void*)_attrs, Yes.Take);
  }

  /**
      Retrieves context around the insertion point. Input methods
      typically want context in order to constrain input text based on
      existing text; this is important for languages such as Thai where
      only some sequences of characters are allowed.
      
      This function is implemented by emitting the
      GtkIMContext::retrieve_surrounding signal on the input method; in
      response to this signal, a widget should provide as much context as
      is available, up to an entire paragraph, by calling
      [gtk.imcontext.IMContext.setSurrounding]. Note that there is no obligation
      for a widget to respond to the ::retrieve_surrounding signal, so input
      methods must be prepared to function without context.
  
      Params:
        text = location to store a UTF-8 encoded
                 string of text holding context around the insertion point.
                 If the function returns true, then you must free the result
                 stored in this location with [glib.global.gfree].
        cursorIndex = location to store byte index of the insertion
                 cursor within text.
      Returns: true if surrounding text was provided; in this case
           you must free the result stored in *text.
  */
  bool getSurrounding(out string text, out int cursorIndex)
  {
    bool _retval;
    char* _text;
    _retval = gtk_im_context_get_surrounding(cast(GtkIMContext*)cPtr, &_text, cast(int*)&cursorIndex);
    text = _text.fromCString(Yes.Free);
    return _retval;
  }

  /**
      Notify the input method that a change such as a change in cursor
      position has been made. This will typically cause the input
      method to clear the preedit state.
  */
  void reset()
  {
    gtk_im_context_reset(cast(GtkIMContext*)cPtr);
  }

  /**
      Set the client window for the input context; this is the
      #GdkWindow in which the input appears. This window is
      used in order to correctly position status windows, and may
      also be used for purposes internal to the input method.
  
      Params:
        window = the client window. This may be null to indicate
                    that the previous client window no longer exists.
  */
  void setClientWindow(gdk.window.Window window = null)
  {
    gtk_im_context_set_client_window(cast(GtkIMContext*)cPtr, window ? cast(GdkWindow*)window.cPtr(No.Dup) : null);
  }

  /**
      Notify the input method that a change in cursor
      position has been made. The location is relative to the client
      window.
  
      Params:
        area = new location
  */
  void setCursorLocation(gdk.rectangle.Rectangle area)
  {
    gtk_im_context_set_cursor_location(cast(GtkIMContext*)cPtr, area ? cast(const(GdkRectangle)*)area.cPtr(No.Dup) : null);
  }

  /**
      Sets surrounding context around the insertion point and preedit
      string. This function is expected to be called in response to the
      GtkIMContext::retrieve_surrounding signal, and will likely have no
      effect if called at other times.
  
      Params:
        text = text surrounding the insertion point, as UTF-8.
                 the preedit string should not be included within
                 text.
        len = the length of text, or -1 if text is nul-terminated
        cursorIndex = the byte index of the insertion cursor within text.
  */
  void setSurrounding(string text, int len, int cursorIndex)
  {
    const(char)* _text = text.toCString(No.Alloc);
    gtk_im_context_set_surrounding(cast(GtkIMContext*)cPtr, _text, len, cursorIndex);
  }

  /**
      Sets whether the IM context should use the preedit string
      to display feedback. If use_preedit is FALSE (default
      is TRUE), then the IM context may use some other method to display
      feedback, such as displaying it in a child of the root window.
  
      Params:
        usePreedit = whether the IM context should use the preedit string.
  */
  void setUsePreedit(bool usePreedit)
  {
    gtk_im_context_set_use_preedit(cast(GtkIMContext*)cPtr, usePreedit);
  }

  /**
      Connect to `Commit` signal.
  
      The ::commit signal is emitted when a complete input sequence
      has been entered by the user. This can be a single character
      immediately after a key press or the final result of preediting.
  
      Params:
        callback = signal callback delegate or function to connect
  
          $(D void callback(string str, gtk.imcontext.IMContext iMContext))
  
          `str` the completed character(s) entered by the user (optional)
  
          `iMContext` the instance the signal is connected to (optional)
  
        after = Yes.After to execute callback after default handler, No.After to execute before (default)
      Returns: Signal ID
  */
  ulong connectCommit(T)(T callback, Flag!"After" after = No.After)
  if (isCallable!T
    && is(ReturnType!T == void)
  && (Parameters!T.length < 1 || (ParameterStorageClassTuple!T[0] == ParameterStorageClass.none && is(Parameters!T[0] == string)))
  && (Parameters!T.length < 2 || (ParameterStorageClassTuple!T[1] == ParameterStorageClass.none && is(Parameters!T[1] : gtk.imcontext.IMContext)))
  && Parameters!T.length < 3)
  {
    extern(C) void _cmarshal(GClosure* _closure, GValue* _returnValue, uint _nParams, const(GValue)* _paramVals, void* _invocHint, void* _marshalData)
    {
      assert(_nParams == 2, "Unexpected number of signal parameters");
      auto _dClosure = cast(DGClosure!T*)_closure;
      Tuple!(Parameters!T) _paramTuple;


      static if (Parameters!T.length > 0)
        _paramTuple[0] = getVal!(Parameters!T[0])(&_paramVals[1]);

      static if (Parameters!T.length > 1)
        _paramTuple[1] = getVal!(Parameters!T[1])(&_paramVals[0]);

      _dClosure.cb(_paramTuple[]);
    }

    auto closure = new DClosure(callback, &_cmarshal);
    return connectSignalClosure("commit", closure, after);
  }

  /**
      Connect to `DeleteSurrounding` signal.
  
      The ::delete-surrounding signal is emitted when the input method
      needs to delete all or part of the context surrounding the cursor.
  
      Params:
        callback = signal callback delegate or function to connect
  
          $(D bool callback(int offset, int nChars, gtk.imcontext.IMContext iMContext))
  
          `offset` the character offset from the cursor position of the text
                    to be deleted. A negative value indicates a position before
                    the cursor. (optional)
  
          `nChars` the number of characters to be deleted (optional)
  
          `iMContext` the instance the signal is connected to (optional)
  
          `Returns` true if the signal was handled.
        after = Yes.After to execute callback after default handler, No.After to execute before (default)
      Returns: Signal ID
  */
  ulong connectDeleteSurrounding(T)(T callback, Flag!"After" after = No.After)
  if (isCallable!T
    && is(ReturnType!T == bool)
  && (Parameters!T.length < 1 || (ParameterStorageClassTuple!T[0] == ParameterStorageClass.none && is(Parameters!T[0] == int)))
  && (Parameters!T.length < 2 || (ParameterStorageClassTuple!T[1] == ParameterStorageClass.none && is(Parameters!T[1] == int)))
  && (Parameters!T.length < 3 || (ParameterStorageClassTuple!T[2] == ParameterStorageClass.none && is(Parameters!T[2] : gtk.imcontext.IMContext)))
  && Parameters!T.length < 4)
  {
    extern(C) void _cmarshal(GClosure* _closure, GValue* _returnValue, uint _nParams, const(GValue)* _paramVals, void* _invocHint, void* _marshalData)
    {
      assert(_nParams == 3, "Unexpected number of signal parameters");
      auto _dClosure = cast(DGClosure!T*)_closure;
      Tuple!(Parameters!T) _paramTuple;


      static if (Parameters!T.length > 0)
        _paramTuple[0] = getVal!(Parameters!T[0])(&_paramVals[1]);


      static if (Parameters!T.length > 1)
        _paramTuple[1] = getVal!(Parameters!T[1])(&_paramVals[2]);

      static if (Parameters!T.length > 2)
        _paramTuple[2] = getVal!(Parameters!T[2])(&_paramVals[0]);

      auto _retval = _dClosure.cb(_paramTuple[]);
      setVal!(bool)(_returnValue, _retval);
    }

    auto closure = new DClosure(callback, &_cmarshal);
    return connectSignalClosure("delete-surrounding", closure, after);
  }

  /**
      Connect to `PreeditChanged` signal.
  
      The ::preedit-changed signal is emitted whenever the preedit sequence
      currently being entered has changed.  It is also emitted at the end of
      a preedit sequence, in which case
      [gtk.imcontext.IMContext.getPreeditString] returns the empty string.
  
      Params:
        callback = signal callback delegate or function to connect
  
          $(D void callback(gtk.imcontext.IMContext iMContext))
  
          `iMContext` the instance the signal is connected to (optional)
  
        after = Yes.After to execute callback after default handler, No.After to execute before (default)
      Returns: Signal ID
  */
  ulong connectPreeditChanged(T)(T callback, Flag!"After" after = No.After)
  if (isCallable!T
    && is(ReturnType!T == void)
  && (Parameters!T.length < 1 || (ParameterStorageClassTuple!T[0] == ParameterStorageClass.none && is(Parameters!T[0] : gtk.imcontext.IMContext)))
  && Parameters!T.length < 2)
  {
    extern(C) void _cmarshal(GClosure* _closure, GValue* _returnValue, uint _nParams, const(GValue)* _paramVals, void* _invocHint, void* _marshalData)
    {
      assert(_nParams == 1, "Unexpected number of signal parameters");
      auto _dClosure = cast(DGClosure!T*)_closure;
      Tuple!(Parameters!T) _paramTuple;

      static if (Parameters!T.length > 0)
        _paramTuple[0] = getVal!(Parameters!T[0])(&_paramVals[0]);

      _dClosure.cb(_paramTuple[]);
    }

    auto closure = new DClosure(callback, &_cmarshal);
    return connectSignalClosure("preedit-changed", closure, after);
  }

  /**
      Connect to `PreeditEnd` signal.
  
      The ::preedit-end signal is emitted when a preediting sequence
      has been completed or canceled.
  
      Params:
        callback = signal callback delegate or function to connect
  
          $(D void callback(gtk.imcontext.IMContext iMContext))
  
          `iMContext` the instance the signal is connected to (optional)
  
        after = Yes.After to execute callback after default handler, No.After to execute before (default)
      Returns: Signal ID
  */
  ulong connectPreeditEnd(T)(T callback, Flag!"After" after = No.After)
  if (isCallable!T
    && is(ReturnType!T == void)
  && (Parameters!T.length < 1 || (ParameterStorageClassTuple!T[0] == ParameterStorageClass.none && is(Parameters!T[0] : gtk.imcontext.IMContext)))
  && Parameters!T.length < 2)
  {
    extern(C) void _cmarshal(GClosure* _closure, GValue* _returnValue, uint _nParams, const(GValue)* _paramVals, void* _invocHint, void* _marshalData)
    {
      assert(_nParams == 1, "Unexpected number of signal parameters");
      auto _dClosure = cast(DGClosure!T*)_closure;
      Tuple!(Parameters!T) _paramTuple;

      static if (Parameters!T.length > 0)
        _paramTuple[0] = getVal!(Parameters!T[0])(&_paramVals[0]);

      _dClosure.cb(_paramTuple[]);
    }

    auto closure = new DClosure(callback, &_cmarshal);
    return connectSignalClosure("preedit-end", closure, after);
  }

  /**
      Connect to `PreeditStart` signal.
  
      The ::preedit-start signal is emitted when a new preediting sequence
      starts.
  
      Params:
        callback = signal callback delegate or function to connect
  
          $(D void callback(gtk.imcontext.IMContext iMContext))
  
          `iMContext` the instance the signal is connected to (optional)
  
        after = Yes.After to execute callback after default handler, No.After to execute before (default)
      Returns: Signal ID
  */
  ulong connectPreeditStart(T)(T callback, Flag!"After" after = No.After)
  if (isCallable!T
    && is(ReturnType!T == void)
  && (Parameters!T.length < 1 || (ParameterStorageClassTuple!T[0] == ParameterStorageClass.none && is(Parameters!T[0] : gtk.imcontext.IMContext)))
  && Parameters!T.length < 2)
  {
    extern(C) void _cmarshal(GClosure* _closure, GValue* _returnValue, uint _nParams, const(GValue)* _paramVals, void* _invocHint, void* _marshalData)
    {
      assert(_nParams == 1, "Unexpected number of signal parameters");
      auto _dClosure = cast(DGClosure!T*)_closure;
      Tuple!(Parameters!T) _paramTuple;

      static if (Parameters!T.length > 0)
        _paramTuple[0] = getVal!(Parameters!T[0])(&_paramVals[0]);

      _dClosure.cb(_paramTuple[]);
    }

    auto closure = new DClosure(callback, &_cmarshal);
    return connectSignalClosure("preedit-start", closure, after);
  }

  /**
      Connect to `RetrieveSurrounding` signal.
  
      The ::retrieve-surrounding signal is emitted when the input method
      requires the context surrounding the cursor.  The callback should set
      the input method surrounding context by calling the
      [gtk.imcontext.IMContext.setSurrounding] method.
  
      Params:
        callback = signal callback delegate or function to connect
  
          $(D bool callback(gtk.imcontext.IMContext iMContext))
  
          `iMContext` the instance the signal is connected to (optional)
  
          `Returns` true if the signal was handled.
        after = Yes.After to execute callback after default handler, No.After to execute before (default)
      Returns: Signal ID
  */
  ulong connectRetrieveSurrounding(T)(T callback, Flag!"After" after = No.After)
  if (isCallable!T
    && is(ReturnType!T == bool)
  && (Parameters!T.length < 1 || (ParameterStorageClassTuple!T[0] == ParameterStorageClass.none && is(Parameters!T[0] : gtk.imcontext.IMContext)))
  && Parameters!T.length < 2)
  {
    extern(C) void _cmarshal(GClosure* _closure, GValue* _returnValue, uint _nParams, const(GValue)* _paramVals, void* _invocHint, void* _marshalData)
    {
      assert(_nParams == 1, "Unexpected number of signal parameters");
      auto _dClosure = cast(DGClosure!T*)_closure;
      Tuple!(Parameters!T) _paramTuple;

      static if (Parameters!T.length > 0)
        _paramTuple[0] = getVal!(Parameters!T[0])(&_paramVals[0]);

      auto _retval = _dClosure.cb(_paramTuple[]);
      setVal!(bool)(_returnValue, _retval);
    }

    auto closure = new DClosure(callback, &_cmarshal);
    return connectSignalClosure("retrieve-surrounding", closure, after);
  }
}
