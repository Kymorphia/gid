module gsk.glshader_node;

import gid.gid;
import glib.bytes;
import gobject.object;
import graphene.rect;
import gsk.c.functions;
import gsk.c.types;
import gsk.glshader;
import gsk.render_node;
import gsk.types;

/**
    A render node using a GL shader when drawing its children nodes.
*/
class GLShaderNode : gsk.render_node.RenderNode
{

  this(void* ptr, Flag!"Take" take = No.Take)
  {
    if (!ptr)
      throw new GidConstructException("Null instance pointer for Gsk.GLShaderNode");

    super(cast(GskRenderNode*)ptr, take);
  }

  /**
      Creates a [gsk.render_node.RenderNode] that will render the given shader into the
    area given by bounds.
    
    The args is a block of data to use for uniform input, as per types and
    offsets defined by the shader. Normally this is generated by
    [gsk.glshader.GLShader.formatArgs] or [gsk.shader_args_builder.ShaderArgsBuilder].
    
    See [gsk.glshader.GLShader] for details about how the shader should be written.
    
    All the children will be rendered into textures (if they aren't already
    `GskTextureNodes`, which will be used directly). These textures will be
    sent as input to the shader.
    
    If the renderer doesn't support GL shaders, or if there is any problem
    when compiling the shader, then the node will draw pink. You should use
    [gsk.glshader.GLShader.compile] to ensure the shader will work for the
    renderer before using it.
    Params:
      shader =       the [gsk.glshader.GLShader]
      bounds =       the rectangle to render the shader into
      args =       Arguments for the uniforms
      children =       array of child nodes,
          these will be rendered to textures and used as input.
    Returns:     A new [gsk.render_node.RenderNode]
  */
  this(gsk.glshader.GLShader shader, graphene.rect.Rect bounds, glib.bytes.Bytes args, gsk.render_node.RenderNode[] children = null)
  {
    GskRenderNode* _cretval;
    uint _nChildren;
    if (children)
      _nChildren = cast(uint)children.length;

    GskRenderNode*[] _tmpchildren;
    foreach (obj; children)
      _tmpchildren ~= obj ? cast(GskRenderNode*)obj.cPtr : null;
    GskRenderNode** _children = cast(GskRenderNode**)_tmpchildren.ptr;
    _cretval = gsk_gl_shader_node_new(shader ? cast(GskGLShader*)shader.cPtr(No.Dup) : null, bounds ? cast(const(graphene_rect_t)*)bounds.cPtr(No.Dup) : null, args ? cast(GBytes*)args.cPtr(No.Dup) : null, _children, _nChildren);
    this(_cretval, Yes.Take);
  }

  /**
      Gets args for the node.
    Returns:     A [glib.bytes.Bytes] with the uniform arguments
  */
  glib.bytes.Bytes getArgs()
  {
    GBytes* _cretval;
    _cretval = gsk_gl_shader_node_get_args(cast(const(GskRenderNode)*)cPtr);
    auto _retval = _cretval ? new glib.bytes.Bytes(cast(void*)_cretval, No.Take) : null;
    return _retval;
  }

  /**
      Gets one of the children.
    Params:
      idx =       the position of the child to get
    Returns:     the idx'th child of node
  */
  gsk.render_node.RenderNode getChild(uint idx)
  {
    GskRenderNode* _cretval;
    _cretval = gsk_gl_shader_node_get_child(cast(const(GskRenderNode)*)cPtr, idx);
    auto _retval = _cretval ? new gsk.render_node.RenderNode(cast(GskRenderNode*)_cretval, No.Take) : null;
    return _retval;
  }

  /**
      Returns the number of children
    Returns:     The number of children
  */
  uint getNChildren()
  {
    uint _retval;
    _retval = gsk_gl_shader_node_get_n_children(cast(const(GskRenderNode)*)cPtr);
    return _retval;
  }

  /**
      Gets shader code for the node.
    Returns:     the [gsk.glshader.GLShader] shader
  */
  gsk.glshader.GLShader getShader()
  {
    GskGLShader* _cretval;
    _cretval = gsk_gl_shader_node_get_shader(cast(const(GskRenderNode)*)cPtr);
    auto _retval = ObjectG.getDObject!(gsk.glshader.GLShader)(cast(GskGLShader*)_cretval, No.Take);
    return _retval;
  }
}
