/// Module for [Context] class
module javascriptcore.context;

import gid.gid;
import glib.types;
import gobject.object;
import javascriptcore.c.functions;
import javascriptcore.c.types;
import javascriptcore.class_;
import javascriptcore.exception;
import javascriptcore.types;
import javascriptcore.value;
import javascriptcore.virtual_machine;

/**
    JSCContext represents a JavaScript execution context, where all operations
    take place and where the values will be associated.
    
    When a new context is created, a global object is allocated and the built-in JavaScript
    objects (Object, Function, String, Array) are populated. You can execute JavaScript in
    the context by using [javascriptcore.context.Context.evaluate] or [javascriptcore.context.Context.evaluateWithSourceUri].
    It's also possible to register custom objects in the context with [javascriptcore.context.Context.registerClass].
*/
class Context : gobject.object.ObjectWrap
{

  /** */
  this(void* ptr, Flag!"Take" take)
  {
    super(cast(void*)ptr, take);
  }

  /** */
  static GType _getGType()
  {
    import gid.loader : gidSymbolNotFound;
    return cast(void function())jsc_context_get_type != &gidSymbolNotFound ? jsc_context_get_type() : cast(GType)0;
  }

  /** */
  override @property GType _gType()
  {
    return _getGType();
  }

  /** Returns `this`, for use in `with` statements. */
  override Context self()
  {
    return this;
  }

  /**
      Create a new #JSCContext. The context is created in a new #JSCVirtualMachine.
      Use [javascriptcore.context.Context.newWithVirtualMachine] to create a new #JSCContext in an
      existing #JSCVirtualMachine.
      Returns: the newly created #JSCContext.
  */
  this()
  {
    JSCContext* _cretval;
    _cretval = jsc_context_new();
    this(_cretval, Yes.Take);
  }

  /**
      Create a new #JSCContext in virtual_machine.
  
      Params:
        vm = a #JSCVirtualMachine
      Returns: the newly created #JSCContext.
  */
  static javascriptcore.context.Context newWithVirtualMachine(javascriptcore.virtual_machine.VirtualMachine vm)
  {
    JSCContext* _cretval;
    _cretval = jsc_context_new_with_virtual_machine(vm ? cast(JSCVirtualMachine*)vm._cPtr(No.Dup) : null);
    auto _retval = gobject.object.ObjectWrap._getDObject!(javascriptcore.context.Context)(cast(JSCContext*)_cretval, Yes.Take);
    return _retval;
  }

  /**
      Get the #JSCContext that is currently executing a function. This should only be
      called within a function or method callback, otherwise null will be returned.
      Returns: the #JSCContext that is currently executing.
  */
  static javascriptcore.context.Context getCurrent()
  {
    JSCContext* _cretval;
    _cretval = jsc_context_get_current();
    auto _retval = gobject.object.ObjectWrap._getDObject!(javascriptcore.context.Context)(cast(JSCContext*)_cretval, No.Take);
    return _retval;
  }

  /**
      Check the given code in context for syntax errors. The line_number is the starting line number in uri;
      the value is one-based so the first line is 1. uri and line_number are only used to fill the exception.
      In case of errors exception will be set to a new #JSCException with the details. You can pass null to
      exception to ignore the error details.
  
      Params:
        code = a JavaScript script to check
        length = length of code, or -1 if code is a nul-terminated string
        mode = a #JSCCheckSyntaxMode
        uri = the source URI
        lineNumber = the starting line number
        exception = return location for a #JSCException, or null to ignore
      Returns: a #JSCCheckSyntaxResult
  */
  javascriptcore.types.CheckSyntaxResult checkSyntax(string code, ptrdiff_t length, javascriptcore.types.CheckSyntaxMode mode, string uri, uint lineNumber, out javascriptcore.exception.ExceptionWrap exception)
  {
    JSCCheckSyntaxResult _cretval;
    const(char)* _code = code.toCString(No.Alloc);
    const(char)* _uri = uri.toCString(No.Alloc);
    JSCException* _exception;
    _cretval = jsc_context_check_syntax(cast(JSCContext*)this._cPtr, _code, length, mode, _uri, lineNumber, &_exception);
    javascriptcore.types.CheckSyntaxResult _retval = cast(javascriptcore.types.CheckSyntaxResult)_cretval;
    exception = new javascriptcore.exception.ExceptionWrap(cast(void*)_exception, Yes.Take);
    return _retval;
  }

  /**
      Clear the uncaught exception in context if any.
  */
  void clearException()
  {
    jsc_context_clear_exception(cast(JSCContext*)this._cPtr);
  }

  /**
      Evaluate code in context.
  
      Params:
        code = a JavaScript script to evaluate
        length = length of code, or -1 if code is a nul-terminated string
      Returns: a #JSCValue representing the last value generated by the script.
  */
  javascriptcore.value.Value evaluate(string code, ptrdiff_t length)
  {
    JSCValue* _cretval;
    const(char)* _code = code.toCString(No.Alloc);
    _cretval = jsc_context_evaluate(cast(JSCContext*)this._cPtr, _code, length);
    auto _retval = gobject.object.ObjectWrap._getDObject!(javascriptcore.value.Value)(cast(JSCValue*)_cretval, Yes.Take);
    return _retval;
  }

  /**
      Evaluate code and create an new object where symbols defined in code will be added as properties,
      instead of being added to context global object. The new object is returned as object parameter.
      Similar to how [javascriptcore.value.Value.newObject] works, if object_instance is not null object_class must be provided too.
      The line_number is the starting line number in uri; the value is one-based so the first line is 1.
      uri and line_number will be shown in exceptions and they don't affect the behavior of the script.
  
      Params:
        code = a JavaScript script to evaluate
        length = length of code, or -1 if code is a nul-terminated string
        objectInstance = an object instance
        objectClass = a #JSCClass or null to use the default
        uri = the source URI
        lineNumber = the starting line number
        object = return location for a #JSCValue.
      Returns: a #JSCValue representing the last value generated by the script.
  */
  javascriptcore.value.Value evaluateInObject(string code, ptrdiff_t length, void* objectInstance, javascriptcore.class_.Class objectClass, string uri, uint lineNumber, out javascriptcore.value.Value object)
  {
    JSCValue* _cretval;
    const(char)* _code = code.toCString(No.Alloc);
    const(char)* _uri = uri.toCString(No.Alloc);
    JSCValue* _object;
    _cretval = jsc_context_evaluate_in_object(cast(JSCContext*)this._cPtr, _code, length, objectInstance, objectClass ? cast(JSCClass*)objectClass._cPtr(No.Dup) : null, _uri, lineNumber, &_object);
    auto _retval = gobject.object.ObjectWrap._getDObject!(javascriptcore.value.Value)(cast(JSCValue*)_cretval, Yes.Take);
    object = new javascriptcore.value.Value(cast(void*)_object, Yes.Take);
    return _retval;
  }

  /**
      Evaluate code in context using uri as the source URI. The line_number is the starting line number
      in uri; the value is one-based so the first line is 1. uri and line_number will be shown in exceptions and
      they don't affect the behavior of the script.
  
      Params:
        code = a JavaScript script to evaluate
        length = length of code, or -1 if code is a nul-terminated string
        uri = the source URI
        lineNumber = the starting line number
      Returns: a #JSCValue representing the last value generated by the script.
  */
  javascriptcore.value.Value evaluateWithSourceUri(string code, ptrdiff_t length, string uri, uint lineNumber)
  {
    JSCValue* _cretval;
    const(char)* _code = code.toCString(No.Alloc);
    const(char)* _uri = uri.toCString(No.Alloc);
    _cretval = jsc_context_evaluate_with_source_uri(cast(JSCContext*)this._cPtr, _code, length, _uri, lineNumber);
    auto _retval = gobject.object.ObjectWrap._getDObject!(javascriptcore.value.Value)(cast(JSCValue*)_cretval, Yes.Take);
    return _retval;
  }

  /**
      Get the last unhandled exception thrown in context by API functions calls.
      Returns: a #JSCException or null if there isn't any
           unhandled exception in the #JSCContext.
  */
  javascriptcore.exception.ExceptionWrap getException()
  {
    JSCException* _cretval;
    _cretval = jsc_context_get_exception(cast(JSCContext*)this._cPtr);
    auto _retval = gobject.object.ObjectWrap._getDObject!(javascriptcore.exception.ExceptionWrap)(cast(JSCException*)_cretval, No.Take);
    return _retval;
  }

  /**
      Get a #JSCValue referencing the context global object
      Returns: a #JSCValue
  */
  javascriptcore.value.Value getGlobalObject()
  {
    JSCValue* _cretval;
    _cretval = jsc_context_get_global_object(cast(JSCContext*)this._cPtr);
    auto _retval = gobject.object.ObjectWrap._getDObject!(javascriptcore.value.Value)(cast(JSCValue*)_cretval, Yes.Take);
    return _retval;
  }

  /**
      Get a property of context global object with name.
  
      Params:
        name = the value name
      Returns: a #JSCValue
  */
  javascriptcore.value.Value getValue(string name)
  {
    JSCValue* _cretval;
    const(char)* _name = name.toCString(No.Alloc);
    _cretval = jsc_context_get_value(cast(JSCContext*)this._cPtr, _name);
    auto _retval = gobject.object.ObjectWrap._getDObject!(javascriptcore.value.Value)(cast(JSCValue*)_cretval, Yes.Take);
    return _retval;
  }

  /**
      Get the #JSCVirtualMachine where context was created.
      Returns: the #JSCVirtualMachine where the #JSCContext was created.
  */
  javascriptcore.virtual_machine.VirtualMachine getVirtualMachine()
  {
    JSCVirtualMachine* _cretval;
    _cretval = jsc_context_get_virtual_machine(cast(JSCContext*)this._cPtr);
    auto _retval = gobject.object.ObjectWrap._getDObject!(javascriptcore.virtual_machine.VirtualMachine)(cast(JSCVirtualMachine*)_cretval, No.Take);
    return _retval;
  }

  /**
      Remove the last #JSCExceptionHandler previously pushed to context with
      [javascriptcore.context.Context.pushExceptionHandler].
  */
  void popExceptionHandler()
  {
    jsc_context_pop_exception_handler(cast(JSCContext*)this._cPtr);
  }

  /**
      Push an exception handler in context. Whenever a JavaScript exception happens in
      the #JSCContext, the given handler will be called. The default #JSCExceptionHandler
      simply calls [javascriptcore.context.Context.throwException] to throw the exception to the #JSCContext.
      If you don't want to catch the exception, but only get notified about it, call
      [javascriptcore.context.Context.throwException] in handler like the default one does.
      The last exception handler pushed is the only one used by the #JSCContext, use
      [javascriptcore.context.Context.popExceptionHandler] to remove it and set the previous one. When handler
      is removed from the context, destroy_notify i called with user_data as parameter.
  
      Params:
        handler = a #JSCExceptionHandler
  */
  void pushExceptionHandler(javascriptcore.types.ExceptionHandler handler)
  {
    extern(C) void _handlerCallback(JSCContext* context, JSCException* exception, void* userData)
    {
      auto _dlg = cast(javascriptcore.types.ExceptionHandler*)userData;

      (*_dlg)(gobject.object.ObjectWrap._getDObject!(javascriptcore.context.Context)(cast(void*)context, No.Take), gobject.object.ObjectWrap._getDObject!(javascriptcore.exception.ExceptionWrap)(cast(void*)exception, No.Take));
    }
    auto _handlerCB = handler ? &_handlerCallback : null;

    auto _handler = handler ? freezeDelegate(cast(void*)&handler) : null;
    GDestroyNotify _handlerDestroyCB = handler ? &thawDelegate : null;
    jsc_context_push_exception_handler(cast(JSCContext*)this._cPtr, _handlerCB, _handler, _handlerDestroyCB);
  }

  /**
      Register a custom class in context using the given name. If the new class inherits from
      another #JSCClass, the parent should be passed as parent_class, otherwise null should be
      used. The optional vtable parameter allows to provide a custom implementation for handling
      the class, for example, to handle external properties not added to the prototype.
      When an instance of the #JSCClass is cleared in the context, destroy_notify is called with
      the instance as parameter.
  
      Params:
        name = the class name
        parentClass = a #JSCClass or null
        vtable = an optional #JSCClassVTable or null
        destroyNotify = a destroy notifier for class instances
      Returns: a #JSCClass
  */
  javascriptcore.class_.Class registerClass(string name, javascriptcore.class_.Class parentClass, javascriptcore.types.ClassVTable vtable, glib.types.DestroyNotify destroyNotify = null)
  {
    extern(C) void _destroyNotifyCallback(void* data)
    {
      ptrThawGC(data);
      auto _dlg = cast(glib.types.DestroyNotify*)data;

      (*_dlg)();
    }
    auto _destroyNotifyCB = destroyNotify ? &_destroyNotifyCallback : null;

    JSCClass* _cretval;
    const(char)* _name = name.toCString(No.Alloc);
    _cretval = jsc_context_register_class(cast(JSCContext*)this._cPtr, _name, parentClass ? cast(JSCClass*)parentClass._cPtr(No.Dup) : null, &vtable, _destroyNotifyCB);
    auto _retval = gobject.object.ObjectWrap._getDObject!(javascriptcore.class_.Class)(cast(JSCClass*)_cretval, No.Take);
    return _retval;
  }

  /**
      Set a property of context global object with name and value.
  
      Params:
        name = the value name
        value = a #JSCValue
  */
  void setValue(string name, javascriptcore.value.Value value)
  {
    const(char)* _name = name.toCString(No.Alloc);
    jsc_context_set_value(cast(JSCContext*)this._cPtr, _name, value ? cast(JSCValue*)value._cPtr(No.Dup) : null);
  }

  /**
      Throw an exception to context using the given error message. The created #JSCException
      can be retrieved with [javascriptcore.context.Context.getException].
  
      Params:
        errorMessage = an error message
  */
  void throw_(string errorMessage)
  {
    const(char)* _errorMessage = errorMessage.toCString(No.Alloc);
    jsc_context_throw(cast(JSCContext*)this._cPtr, _errorMessage);
  }

  /**
      Throw exception to context.
  
      Params:
        exception = a #JSCException
  */
  void throwException(javascriptcore.exception.ExceptionWrap exception)
  {
    jsc_context_throw_exception(cast(JSCContext*)this._cPtr, exception ? cast(JSCException*)exception._cPtr(No.Dup) : null);
  }

  /**
      Throw an exception to context using the given error name and message. The created #JSCException
      can be retrieved with [javascriptcore.context.Context.getException].
  
      Params:
        errorName = the error name
        errorMessage = an error message
  */
  void throwWithName(string errorName, string errorMessage)
  {
    const(char)* _errorName = errorName.toCString(No.Alloc);
    const(char)* _errorMessage = errorMessage.toCString(No.Alloc);
    jsc_context_throw_with_name(cast(JSCContext*)this._cPtr, _errorName, _errorMessage);
  }
}
