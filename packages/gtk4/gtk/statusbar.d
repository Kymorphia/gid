/// Module for [Statusbar] class
module gtk.statusbar;

import gid.gid;
import gobject.dclosure;
import gtk.accessible;
import gtk.accessible_mixin;
import gtk.buildable;
import gtk.buildable_mixin;
import gtk.c.functions;
import gtk.c.types;
import gtk.constraint_target;
import gtk.constraint_target_mixin;
import gtk.types;
import gtk.widget;

/**
    A [gtk.statusbar.Statusbar] widget is usually placed along the bottom of an application's
    main [gtk.window.Window].
    
    ![An example GtkStatusbar](statusbar.png)
    
    A `GtkStatusBar` may provide a regular commentary of the application's
    status (as is usually the case in a web browser, for example), or may be
    used to simply output a message when the status changes, (when an upload
    is complete in an FTP client, for example).
    
    Status bars in GTK maintain a stack of messages. The message at
    the top of the each bar’s stack is the one that will currently be displayed.
    
    Any messages added to a statusbar’s stack must specify a context id that
    is used to uniquely identify the source of a message. This context id can
    be generated by [gtk.statusbar.Statusbar.getContextId], given a message and
    the statusbar that it will be added to. Note that messages are stored in a
    stack, and when choosing which message to display, the stack structure is
    adhered to, regardless of the context identifier of a message.
    
    One could say that a statusbar maintains one stack of messages for
    display purposes, but allows multiple message producers to maintain
    sub-stacks of the messages they produced (via context ids).
    
    Status bars are created using [gtk.statusbar.Statusbar.new_].
    
    Messages are added to the bar’s stack with [gtk.statusbar.Statusbar.push].
    
    The message at the top of the stack can be removed using
    [gtk.statusbar.Statusbar.pop]. A message can be removed from anywhere in the
    stack if its message id was recorded at the time it was added. This is done
    using [gtk.statusbar.Statusbar.remove].
    
    ## CSS node
    
    [gtk.statusbar.Statusbar] has a single CSS node with name `statusbar`.

    Deprecated: This widget will be removed in GTK 5
*/
class Statusbar : gtk.widget.Widget
{

  /** */
  this(void* ptr, Flag!"Take" take = No.Take)
  {
    super(cast(void*)ptr, take);
  }

  /** */
  static GType getGType()
  {
    import gid.loader : gidSymbolNotFound;
    return cast(void function())gtk_statusbar_get_type != &gidSymbolNotFound ? gtk_statusbar_get_type() : cast(GType)0;
  }

  /** */
  override @property GType gType()
  {
    return getGType();
  }

  override Statusbar self()
  {
    return this;
  }

  /**
      Creates a new [gtk.statusbar.Statusbar] ready for messages.
      Returns: the new [gtk.statusbar.Statusbar]
  
      Deprecated: This widget will be removed in GTK 5
  */
  this()
  {
    GtkWidget* _cretval;
    _cretval = gtk_statusbar_new();
    this(_cretval, No.Take);
  }

  /**
      Returns a new context identifier, given a description
      of the actual context.
      
      Note that the description is not shown in the UI.
  
      Params:
        contextDescription = textual description of what context
            the new message is being used in
      Returns: an integer id
  
      Deprecated: This widget will be removed in GTK 5
  */
  uint getContextId(string contextDescription)
  {
    uint _retval;
    const(char)* _contextDescription = contextDescription.toCString(No.Alloc);
    _retval = gtk_statusbar_get_context_id(cast(GtkStatusbar*)cPtr, _contextDescription);
    return _retval;
  }

  /**
      Removes the first message in the [gtk.statusbar.Statusbar]’s stack
      with the given context id.
      
      Note that this may not change the displayed message,
      if the message at the top of the stack has a different
      context id.
  
      Params:
        contextId = a context identifier
  
      Deprecated: This widget will be removed in GTK 5
  */
  void pop(uint contextId)
  {
    gtk_statusbar_pop(cast(GtkStatusbar*)cPtr, contextId);
  }

  /**
      Pushes a new message onto a statusbar’s stack.
  
      Params:
        contextId = the message’s context id, as returned by
             [gtk.statusbar.Statusbar.getContextId]
        text = the message to add to the statusbar
      Returns: a message id that can be used with
          [gtk.statusbar.Statusbar.remove].
  
      Deprecated: This widget will be removed in GTK 5
  */
  uint push(uint contextId, string text)
  {
    uint _retval;
    const(char)* _text = text.toCString(No.Alloc);
    _retval = gtk_statusbar_push(cast(GtkStatusbar*)cPtr, contextId, _text);
    return _retval;
  }

  /**
      Forces the removal of a message from a statusbar’s stack.
      The exact context_id and message_id must be specified.
  
      Params:
        contextId = a context identifier
        messageId = a message identifier, as returned by [gtk.statusbar.Statusbar.push]
  
      Deprecated: This widget will be removed in GTK 5
  */
  void remove(uint contextId, uint messageId)
  {
    gtk_statusbar_remove(cast(GtkStatusbar*)cPtr, contextId, messageId);
  }

  /**
      Forces the removal of all messages from a statusbar's
      stack with the exact context_id.
  
      Params:
        contextId = a context identifier
  
      Deprecated: This widget will be removed in GTK 5
  */
  void removeAll(uint contextId)
  {
    gtk_statusbar_remove_all(cast(GtkStatusbar*)cPtr, contextId);
  }

  /**
      Connect to `TextPopped` signal.
  
      Emitted whenever a new message is popped off a statusbar's stack.
  
      Params:
        callback = signal callback delegate or function to connect
  
          $(D void callback(uint contextId, string text, gtk.statusbar.Statusbar statusbar))
  
          `contextId` the context id of the relevant message/statusbar (optional)
  
          `text` the message that was just popped (optional)
  
          `statusbar` the instance the signal is connected to (optional)
  
        after = Yes.After to execute callback after default handler, No.After to execute before (default)
      Returns: Signal ID
  
      Deprecated: This widget will be removed in GTK 5
  */
  ulong connectTextPopped(T)(T callback, Flag!"After" after = No.After)
  if (isCallable!T
    && is(ReturnType!T == void)
  && (Parameters!T.length < 1 || (ParameterStorageClassTuple!T[0] == ParameterStorageClass.none && is(Parameters!T[0] == uint)))
  && (Parameters!T.length < 2 || (ParameterStorageClassTuple!T[1] == ParameterStorageClass.none && is(Parameters!T[1] == string)))
  && (Parameters!T.length < 3 || (ParameterStorageClassTuple!T[2] == ParameterStorageClass.none && is(Parameters!T[2] : gtk.statusbar.Statusbar)))
  && Parameters!T.length < 4)
  {
    extern(C) void _cmarshal(GClosure* _closure, GValue* _returnValue, uint _nParams, const(GValue)* _paramVals, void* _invocHint, void* _marshalData)
    {
      assert(_nParams == 3, "Unexpected number of signal parameters");
      auto _dClosure = cast(DGClosure!T*)_closure;
      Tuple!(Parameters!T) _paramTuple;


      static if (Parameters!T.length > 0)
        _paramTuple[0] = getVal!(Parameters!T[0])(&_paramVals[1]);


      static if (Parameters!T.length > 1)
        _paramTuple[1] = getVal!(Parameters!T[1])(&_paramVals[2]);

      static if (Parameters!T.length > 2)
        _paramTuple[2] = getVal!(Parameters!T[2])(&_paramVals[0]);

      _dClosure.cb(_paramTuple[]);
    }

    auto closure = new DClosure(callback, &_cmarshal);
    return connectSignalClosure("text-popped", closure, after);
  }

  /**
      Connect to `TextPushed` signal.
  
      Emitted whenever a new message gets pushed onto a statusbar's stack.
  
      Params:
        callback = signal callback delegate or function to connect
  
          $(D void callback(uint contextId, string text, gtk.statusbar.Statusbar statusbar))
  
          `contextId` the context id of the relevant message/statusbar (optional)
  
          `text` the message that was pushed (optional)
  
          `statusbar` the instance the signal is connected to (optional)
  
        after = Yes.After to execute callback after default handler, No.After to execute before (default)
      Returns: Signal ID
  
      Deprecated: This widget will be removed in GTK 5
  */
  ulong connectTextPushed(T)(T callback, Flag!"After" after = No.After)
  if (isCallable!T
    && is(ReturnType!T == void)
  && (Parameters!T.length < 1 || (ParameterStorageClassTuple!T[0] == ParameterStorageClass.none && is(Parameters!T[0] == uint)))
  && (Parameters!T.length < 2 || (ParameterStorageClassTuple!T[1] == ParameterStorageClass.none && is(Parameters!T[1] == string)))
  && (Parameters!T.length < 3 || (ParameterStorageClassTuple!T[2] == ParameterStorageClass.none && is(Parameters!T[2] : gtk.statusbar.Statusbar)))
  && Parameters!T.length < 4)
  {
    extern(C) void _cmarshal(GClosure* _closure, GValue* _returnValue, uint _nParams, const(GValue)* _paramVals, void* _invocHint, void* _marshalData)
    {
      assert(_nParams == 3, "Unexpected number of signal parameters");
      auto _dClosure = cast(DGClosure!T*)_closure;
      Tuple!(Parameters!T) _paramTuple;


      static if (Parameters!T.length > 0)
        _paramTuple[0] = getVal!(Parameters!T[0])(&_paramVals[1]);


      static if (Parameters!T.length > 1)
        _paramTuple[1] = getVal!(Parameters!T[1])(&_paramVals[2]);

      static if (Parameters!T.length > 2)
        _paramTuple[2] = getVal!(Parameters!T[2])(&_paramVals[0]);

      _dClosure.cb(_paramTuple[]);
    }

    auto closure = new DClosure(callback, &_cmarshal);
    return connectSignalClosure("text-pushed", closure, after);
  }
}
